# Our goal:
Re-write the 4. 実践的な活用手順 to be consistent to section [3.3 対話的な改善方法] [パターン1: 段階的構築アプローチ] on **AI-CodeGeneration.md** file.

# Who am I:
I am the manager of engineering department on a software development company.

# Your role in this task:
You are an expert in AI Driven and prompt engineering.
You are also an expert in Japanese grammar and linguistics

# Context: 
the whole section [4. 実践的な活用手順] is not consitent to what is written on [3.3 対話的な改善方法] [パターン1: 段階的構築アプローチ].
I have done a research about AI driven development best practices, asking about differences on “Skeleton first” vs “Functional first” and the result is the following:
---
# Workflow that works (loop these steps)
- State the goal + constraints. Tech stack, versions, framework style, coding standards, error strategy, logging, nullability, etc.
- Provide a tiny, verifiable scope. One class/feature/endpoint “vertical slice” with success criteria.
- Ask for a functional baseline + tests. Get something that compiles and runs, not just a skeleton.
- Run it locally. Compile, run tests, try a real call. Note concrete failures/gaps.
- Give targeted feedback. Show failing test output, stack traces, performance numbers.
- Harden. Add edge cases, error handling, transactions, retries, timeouts, auth, logging.
- Refactor & document. Ask AI to refactor into agreed patterns; add Javadoc, ADR-style notes.

# “Skeleton first” vs “Functional first”
- Skeleton-only first is useful when you’re designing an interface/contract that many teams depend on (e.g., public API, SPI, big module boundary). You want agreement on types and method shapes before implementation.
- Functional baseline first (recommended for most tasks): ask AI to produce a minimal working class + unit tests that compiles and proves the happy path. Then iterate to add correctness, edge cases, and quality attributes. This avoids the “skeleton drift” and saves cycles
---
The result of my research was better and more consistent to what we have on the current section [3.3 対話的な改善方法] [パターン1: 段階的構築アプローチ]

# Your job is:
Your job is re-write the [4. 実践的な活用手順] section.
please re-write the section [4.1 開発フローへの組み込み方]
according to what is described on [3.3 対話的な改善方法] [パターン1: 段階的構築アプローチ], taking under consideration the result of the research.
also re-write the [4.2 具体例：タスク管理アプリケーションの開発] section.
for the sample prompts of a real application, 
in  [ステップ1: 基本実装を依頼]
let's simulate the implementation of the Task entity with the following attributes:
- 属性：
  - id (Long型、主キー、自動生成)
  - title (String型、必須、最大100文字)
  - description (String型、最大500文字)
  - status (ENUM型：TODO, IN_PROGRESS, DONE)
  - priority (ENUM型：LOW, MEDIUM, HIGH)
  - dueDate (LocalDateTime型)
  - createdAt (LocalDateTime型、自動設定)
  - updatedAt (LocalDateTime型、自動更新)
  - userId (Long型、外部キー)
and the basic implementation of the Service class.
on [ステップ2: 機能追加]
add some of the features of the TaskService class
on [ステップ3: 品質向上]
add the include the edge cases and error handling and log details.

Provide your ansewrs in Japanese is a must.
