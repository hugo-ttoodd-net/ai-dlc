# AI駆動開発ガイドライン
ソフトウェア開発チーム向け実践指南書

---

## 目次

1. [はじめに](#1-はじめに)
2. [AI駆動開発ライフサイクル（AI-DLC）の概要](#2-ai駆動開発ライフサイクルai-dlcの概要)
3. [組織体制と役割定義](#3-組織体制と役割定義)
4. [開発プロセスの詳細](#4-開発プロセスの詳細)
5. [AIとの効果的な対話方法](#5-aiとの効果的な対話方法)
6. [各フェーズにおける責任分担](#6-各フェーズにおける責任分担)
7. [成功のためのベストプラクティス](#7-成功のためのベストプラクティス)
8. [課題解決とトラブルシューティング](#8-課題解決とトラブルシューティング)
9. [付録](#9-付録)

---

## 1. はじめに

### 1.1 背景

現在のソフトウェア開発では、市場の急激な変化に迅速に対応し、競争力を維持することが求められています。しかし、従来の開発手法では以下のような課題が顕著になっています。

- **開発速度の限界**: 企画から実装まで数週間から数ヶ月を要し、市場変化に追いつけない
- **品質とスピードの両立困難**: 迅速な開発を求めると品質が低下し、品質を重視すると開発が遅くなる
- **属人的な知識への依存**: 特定の開発者に頼った開発体制により、チーム全体のスケーラビリティに課題
- **定型作業への時間浪費**: 開発者が創造的な問題解決よりも定型作業に多くの時間を費やしている

生成AI技術の登場により、これらの課題を根本的に解決する新しい開発手法の導入が可能になりました。

### 1.2 このガイドラインの目的

当社の開発チームがAI駆動開発ライフサイクルを効果的に実践し、以下の目標を達成することを支援します。

- **市場対応力の向上**: 迅速な開発サイクルにより、変化する市場ニーズに素早く対応
- **開発速度の飛躍的向上**: AI技術の活用により、従来数週間の作業を数日から数時間に短縮
- **コスト効率の最適化**: 少数精鋭チームでの高品質な開発を実現し、コストを削減

### 1.3 期待される効果

AI駆動開発ライフサイクルの導入により、以下の効果が期待できます。

- **開発速度**: 従来の開発プロセスと比較して大幅な時間短縮
- **事業部との連携強化**: プロダクトオーナーと開発者がリアルタイムで認識を合わせ、迅速な意思決定を実現
- **ナレッジ共有の促進**: モブ手法を通じて事業部と開発チーム間でのドメイン知識と技術知識の相互理解が深化

### 1.4 成功のための前提条件

このガイドラインを効果的に実践するには、チームメンバーが「AI-Ready」な状態であることが重要です。AI-Readyとは、AIを業務課題に適切に活用し、ユーザー価値を創出できる状態を指します。

#### 必要なマインドセット

- **「完璧な一振り」から「高速な試行錯誤」への転換**: 時間をかけた重厚な開発から、AIとの対話による高速なイテレーションへの思考転換
- **AIとの適切な協働関係**: AIを魔法の箱ではなく、明確な指示を必要とする「優秀なパートナー」として理解
- **試行回数の重視**: 一回あたりのコストを下げることで試行回数を増やし、成果の総量を向上
- **責任感ある活用**: AI生成結果に対する最終的な品質と影響について責任を持つ姿勢

#### 必要なスキル

- **Context Engineering**: AIに「何を」「どういう前提で」「どんな目的で」考えさせるかをコントロールするためのプロンプトを作成するスキル
- **明確な指示設計**: AIが期待する成果を生み出すための具体的で構造化された指示を作成するスキル
- **基本的なプログラミングスキル**: 少なくとも1つのプログラミング言語での開発経験
- **業務ドメイン理解**: 開発対象となる業務領域の基本的な理解

#### 必要な環境

- **AIツールへのアクセス**: GitHub Copilot、DevinまたはClaude等の生成AIツールの利用環境
- **構造化された情報管理**: AIが動的に情報を取得・活用できるシステム基盤
- **セキュアなガバナンス体制**: セキュリティポリシーに基づく安全な運用環境

---

## 2. AI駆動開発ライフサイクル（AI-DLC）の概要

### 2.1 AI-DLCの基本理念

AI-DLCは、従来の人間主導の開発プロセスを根本的に見直し、AIを中心的な協働者として位置づけた新しい開発手法です。以下の核心原則に基づいています。

#### 原則1: 改修ではなく再設計
従来のアジャイル手法にAIを後付けするのではなく、AI時代に最適化された全く新しい手法として設計。週単位から時間・日単位の高速イテレーションを実現します。

#### 原則2: 会話の主導権の転換
従来の「人間がAIに指示する」モデルから「AIが提案し、人間が判断する」モデルへの転換。AIが積極的にワークフローを主導し、人間は重要な意思決定に集中します。

#### 原則3: ビジネスドメインの理解統合
AIが業務ドメインの理解とモデリングを支援し、ビジネスロジックを適切にコードに反映。人間は業務知識の提供と、AIが生成したモデルの妥当性検証に専念します。

#### 原則4: AI能力との整合
現在のAI技術の能力と限界を正確に把握し、人間の監督下でAIの強みを最大化する設計です。

### 2.2 従来手法との比較

| 項目 | 従来のアジャイル | AI-DLC |
|------|----------------|--------|
| イテレーション期間 | 2-4週間（スプリント） | 数時間-数日（ボルト） |
| 主導者 | 人間（PO） | AI（人間は監督・判断） |
| 設計手法 | チーム選択 | AI支援ドメインモデリング |
| 協働形態 | 個別作業+定期会議 | モブ手法（リアルタイム協働） |
| 文書化 | 人間が手動作成 | AI自動生成+人間検証 |
| テスト | 人間主導の設計・実装 | AI自動生成+包括カバレッジ |

### 2.3 AI-DLCの3つのフェーズ

AI-DLCでは、AIがワークフローを開始し、指示する新しいメンタルモデルを採用します。AIが計画を作成し、明確化のための質問をし、人間の検証を受けた後にソリューションを実装します。

#### フェーズ1: 開始（Inception）- ビジネス意図の詳細化

**目的**: ビジネス意図を実装可能な詳細要件に変換

**AIの役割**:
- ビジネス意図の分析と質問の生成
- ユーザーストーリーの詳細化提案
- 要件の構造化と整理
- 作業単位への分割提案

**人間の役割**:
- ビジネス要求の明確化
- AIの質問への回答
- 生成された要件の妥当性検証
- 優先順位付けの決定

**主要活動**:
- **既存システムの理解**: 現在のシステム状況をAIが分析
- **意図の詳細化**: AIとの対話を通じてビジネス要求を具体化
- **ユーザーストーリー作成**: 実装可能な単位での要求整理
- **作業単位計画**: 独立して開発可能な機能ブロックの定義

**成果物**: 詳細化された要件仕様書、ユーザーストーリー、作業単位（Units）

#### フェーズ2: 構築（Construction）- 設計と実装

**目的**: 検証済みの要件から実際に動作するソフトウェアを生成

**人間の役割**:
- **技術仕様の提供**: 使用技術、アーキテクチャパターン、コーディング規約などをAIに指示
- **技術スタックの決定**: プログラミング言語、フレームワーク、データベースなどの選定
- **アーキテクチャ検証**: AIが提案するシステム構造の妥当性確認
- **コード品質確認**: AI生成コードのレビューと調整指示

**AIの役割**:
- 技術仕様に基づくドメインモデルと業務ロジックの提案
- 指定されたアーキテクチャパターンでのシステム設計
- 技術スタックに準拠した実装コードの生成
- 指定されたテストフレームワークでのテストケース自動作成

**主要活動**:
- **技術仕様の明確化**: AIに対する詳細な技術要求の説明
- **ドメインモデリング**: 技術制約を考慮した業務概念の構造化
- **アーキテクチャ設計**: 指定された技術スタックでのシステム全体構造の提案
- **コード生成**: 技術仕様に従った実装コードの生成とリアルタイムレビュー
- **テスト作成**: 指定されたテスト戦略に基づく包括的なテストケース生成

**成果物**: ドメインモデル、アーキテクチャ設計書、実装コード、テストスイート

#### フェーズ3: 運用（Operation）- インフラとデプロイ

**目的**: システムの安全で効率的な運用環境を構築

**AIの役割**:
- インフラストラクチャのコード化
- デプロイメントパイプラインの構築
- 監視とアラートの設定
- 運用メトリクスの分析

**人間の役割**:
- セキュリティポリシーの定義
- 運用要件の承認
- 障害対応の最終判断
- パフォーマンス基準の設定

**主要活動**:
- **Infrastructure as Code**: AIによるインフラ定義の生成
- **CI/CDパイプライン構築**: 自動化されたデプロイメント環境の整備
- **監視体制確立**: システム稼働状況の可視化
- **運用自動化**: 定常的な運用作業のAI支援

**成果物**: デプロイ可能なシステム、Infrastructure as Codeファイル、監視・運用体制

---

## 3. 組織体制と役割定義

### 3.1 コアチーム構成

AI-DLCの成功には、適切なチーム構成が不可欠です。

#### 3.1.1 プロダクトオーナー（Product Owner）

**主要責任**:
- ビジネス価値の定義と優先順位付け
- 事業部との調整
- AI生成要件の業務的妥当性の検証
- 受け入れ基準の最終承認

**必要スキル**:
- ドメイン知識の深い理解
- ステークホルダー管理能力
- 基本的なプロンプトエンジニアリング

#### 3.1.2 開発者（Developer）

**主要責任**:
- 技術的アーキテクチャの決定
- AIエージェントの操作と監督
- コード品質の保証
- チーム内での技術指導

**必要スキル**:
- プログラミングの豊富な経験
- アーキテクチャ設計能力
- 業務ロジックをコードに反映する能力
- 高度なプロンプトエンジニアリング

### 3.2 プロダクトオーナーと開発者のペアリング

AI-DLCの核心は、プロダクトオーナーと開発者の密接な協働です。

#### ペアリングの重要性
- **ビジネスと技術の橋渡し**: ビジネス要求を技術的実装に正確に変換
- **リアルタイム意思決定**: その場での迅速な判断により開発速度を向上
- **品質保証**: 双方の専門知識による多角的な検証

#### 効果的なペアリングの条件
- **物理的近接性**: 同じ空間での作業による即座のコミュニケーション
- **相互理解**: お互いの専門領域への基本的な理解
- **共通目標**: プロジェクト成功への共同責任

---

## 4. 開発プロセスの詳細

### 4.1 開始フェーズ（Inception）

#### 4.1.1 目的と概要
開始フェーズでは、ビジネス意図を具体的で実装可能な要件に変換します。チーム全体でAIと協働しながら要件を詳細化し、実装に必要な情報を整理します。

#### 4.1.2 チーム協働による要件詳細化

**実施環境**:
- オンライン会議システム（リモートワーク対応）
- 画面共有とリアルタイム協働ツール
- 全参加者が同じ画面を見ながら作業できる環境

**参加者**:
- プロダクトオーナー（ファシリテーター）
- 開発者
- 関連する事業部のステークホルダー

**進行手順**:

1. **意図の明確化**（30分）
   - プロダクトオーナーがビジネス意図を提示
   - 現在のシステム状況をAIが分析
   - チーム全体での意図の確認と合意

2. **AIとの対話セッション**（60分）
   - 要件定義プロンプトの実行
   - AIからの質問への回答
   - 要件の詳細化と検証

3. **ユーザーストーリーの作成**（90分）
   - AIによるユーザーストーリーの生成
   - 受け入れ基準の定義
   - チームでの検証と調整

4. **作業単位の構成**（60分）
   - 関連するストーリーのグループ化
   - 独立した作業単位の定義
   - 依存関係の明確化

### 4.2 構築フェーズ（Construction）

#### 4.2.1 技術仕様の明確化

**開始前準備**:
- 対象となる作業単位の選定
- チームメンバーの役割分担
- 開発環境とツールの準備

**技術詳細の定義**:
- **技術スタックの決定**: プログラミング言語、フレームワーク、ライブラリの指定
- **アーキテクチャパターンの選択**: システム構造とデザインパターンの決定
- **データベース設計指針**: データモデルと制約の定義
- **非機能要件の明確化**: パフォーマンス、セキュリティ、可用性の要求定義

#### 4.2.2 チーム協働による実装

**実施プロセス**:

1. **業務ドメインのモデリング**（45分）
   - ユーザーストーリーの再確認
   - ビジネスルールの明確化
   - AIによる業務概念の構造化

2. **AIによるシステム設計**（60分）
   - 指定された技術仕様に基づく設計提案
   - コンポーネント間の関係性定義
   - データフローの設計

3. **チームによる設計検証**（90分）
   - 生成された設計の妥当性確認
   - ビジネス要件との整合性検証
   - 技術的制約との適合性確認

4. **AIによるコード生成と検証**（2時間）
   - 技術仕様に従った初期コード生成
   - リアルタイムコードレビュー
   - AIによるテスト作成（並行実施）

### 4.3 運用フェーズ（Operation）

#### 4.3.1 デプロイメント準備

**Infrastructure as Code**:
- TerraformまたはCloudFormationによるインフラ定義
- AIによるインフラコードの生成
- セキュリティ設定の検証

**CI/CDパイプライン**:
- GitHub ActionsまたはAWS CodePipelineの設定
- 自動化されたテストの統合
- デプロイメント戦略の実装

#### 4.3.2 監視と運用

**観測可能性**:
- メトリクス、ログ、トレースの設定
- AIによる異常検知の実装
- アラートの設定

**継続的改善**:
- パフォーマンスデータの分析
- ユーザーフィードバックの収集
- 次回イテレーションへの反映

---

## 5. AIとの効果的な対話方法

### 5.1 効果的なプロンプトエンジニアリングの原則

#### 5.1.1 明確性の原則
AIとの対話では、曖昧さを排除し、具体的で明確な指示を与えることが重要です。

**良い例**:
```
ユーザー管理システムの新規ユーザー登録機能を実装します。
以下の要件を満たすユーザーストーリーを作成してください：
- メールアドレスによる認証
- パスワード強度チェック
- 重複登録の防止
- 登録完了メールの送信
```

**悪い例**:
```
ユーザーに関する機能を作ってください。
```

#### 5.1.2 コンテキストの提供
AIが適切な判断を行うために、十分な背景情報を提供する必要があります。

**コンテキスト提供のテンプレート**:
```
【プロジェクト概要】
システム名：○○システム
対象ユーザー：○○業界の○○担当者
主要機能：○○、○○、○○

【技術環境】
フロントエンド：React + TypeScript
バックエンド：Spring Boot + Java
データベース：PostgreSQL
クラウド：AWS

【現在の状況】
○○機能は既に実装済み
○○との連携が必要
○○の制約がある
```

### 5.2 フェーズ別プロンプト戦略

#### 5.2.1 要件定義フェーズのプロンプト

```markdown
# 【ゴール・目的】
事業部ステークホルダーやプロダクトオーナーとの会議内容を整理し、
顧客に提供する価値を明確にした上で、ソフトウェア要件としてまとめる

# 【AIとしての役割】
- プロダクトオーナーを支援するAIアシスタントとして行動
- ビジネス価値を意識した要件変換
- 曖昧な点の明確な指摘

# 【コンテキスト】
[プロジェクト固有の情報を詳細に記載]

# 【期待するアウトプット】
[具体的な成果物の形式を指定]
```

#### 5.2.2 バックログ作成フェーズのプロンプト

```markdown
# バックログ作成指示

## 入力情報
- 要件定義サマリー：[添付ファイル]
- 技術的制約：[技術メンバーからの補足]
- ビジネス優先度：[プロダクトオーナーからの指示]

## 期待するアウトプット
| エピック | フィーチャー | ユーザーストーリー | 顧客メリット | ビジネス価値 | 受け入れ基準 |
|---------|-------------|------------------|-------------|-------------|-------------|

## 品質基準
- 各ストーリーはINVEST原則に準拠
- 受け入れ基準は測定可能
- ビジネス価値が明確
```

### 5.3 AI対話のベストプラクティス

#### 5.3.1 質問技法

**オープンな質問の活用**:
```
「この機能について、他に考慮すべき点はありますか？」
「類似のシステムでよく見られる課題は何ですか？」
「この実装方法の代替案はありますか？」
```

**確認質問の重要性**:
```
「私の理解が正しいか確認させてください...」
「この解釈で合っていますか？」
「追加の情報が必要な部分はありますか？」
```

#### 5.3.2 反復的改善

**フィードバックループの確立**:
1. AIからの提案を受領
2. チームでの検証と議論
3. 修正点のフィードバック
4. 改良された提案の確認
5. 最終的な合意形成

---

## 6. 各フェーズにおける責任分担

### 6.1 責任分担（RACI）マトリックスの概要

RACI は以下の責任分担を表します：
- **R (Responsible)**: 実行責任者
- **A (Accountable)**: 説明責任者
- **C (Consulted)**: 相談を受ける人
- **I (Informed)**: 報告を受ける人

### 6.2 開始フェーズ RACI

| 活動 | プロダクトオーナー | 開発者 |
|------|------------------|--------|
| ビジネス意図の明確化 | A | C |
| 要件定義プロンプト実行 | R | R |
| AIとの質疑応答 | A | R |
| ユーザーストーリー検証 | A | R |
| 受け入れ基準定義 | A | C |
| Units構成決定 | A | R |
| 技術的実現可能性確認 | C | A |
| 優先順位決定 | A | C |

### 6.3 構築フェーズ RACI

| 活動 | プロダクトオーナー | 開発者 |
|------|------------------|--------|
| ドメインモデル設計 | C | A |
| アーキテクチャ決定 | I | A |
| コード生成監督 | I | A |
| コードレビュー | I | A |
| 単体テスト生成 | I | R |
| 統合テスト設計 | C | R |
| セキュリティ検証 | I | R |
| パフォーマンステスト | I | R |

### 6.4 運用フェーズ RACI

| 活動 | プロダクトオーナー | 開発者 |
|------|------------------|--------|
| IaCコード生成 | I | C |
| CI/CDパイプライン構築 | I | R |
| デプロイメント実行 | I | C |
| 監視設定 | I | C |
| 障害対応 | I | R |
| パフォーマンス分析 | C | R |
| セキュリティ監視 | I | C |

---

## 7. 成功のためのベストプラクティス

### 7.1 チーム協働のベストプラクティス

#### 7.1.1 モブ作業の効果的運営

**物理環境の最適化**:
- 大型ディスプレイ（55インチ以上推奨）
- 全員がスクリーンを見やすい座席配置
- ホワイトボードの活用
- 適切な室温と照明

**時間管理**:
- 25分作業 + 5分休憩のポモドーロ技法
- 2時間毎の長期休憩
- 集中力維持のための定期的なローテーション

#### 7.1.2 リモート環境での対応

**技術ツール**:
- 高品質なビデオ会議システム（Zoom、Teams等）
- 画面共有とリモート操作ツール
- リアルタイム協働エディタ（VS Code Live Share等）
- デジタルホワイトボード（Miro、Figma等）

**コミュニケーション戦略**:
- 明確な音声環境の確保
- カメラ常時オンの推奨
- チャットツールの併用
- 定期的な接続確認

### 7.2 AI活用のベストプラクティス

#### 7.2.1 プロンプト品質向上

**明確性の確保**:
```markdown
# 良いプロンプトの例
ユーザー管理機能のUser Entityクラスを作成してください。
要件：
- ID（UUID）
- メールアドレス（ユニーク制約）
- パスワード（ハッシュ化）
- 作成日時・更新日時
- アクティブ状態フラグ

技術スタック：
- Java 17
- Spring Boot 3.0
- JPA/Hibernate
- バリデーション注釈の使用

期待するアウトプット：
- Entity クラスソースコード
- バリデーション仕様
- JPA アノテーション
```

#### 7.2.2 AI生成コードの検証方法

**品質チェックリスト**:
- [ ] ビジネスロジックの正確性
- [ ] セキュリティベストプラクティスの準拠
- [ ] パフォーマンス考慮事項
- [ ] 可読性とメンテナンス性
- [ ] テストカバレッジ
- [ ] エラーハンドリング

### 7.3 品質保証のベストプラクティス

#### 7.3.1 テスト戦略

**テストピラミッドの実装**:
```
     E2E Tests (少数)
    Integration Tests (中数)
   Unit Tests (多数)
```

**AI支援テスト生成**:
- 境界値テストケースの自動生成
- 異常系シナリオの網羅
- パフォーマンステストの設計
- セキュリティテストケース

#### 7.3.2 継続的インテグレーション

**CI/CDパイプライン構成**:
```yaml
stages:
  - lint: コード品質チェック
  - unit-test: 単体テスト実行
  - security-scan: セキュリティスキャン
  - integration-test: 統合テスト
  - e2e-test: E2Eテスト
  - deploy: デプロイメント
```

**品質ゲート**:
- コードカバレッジ 80% 以上
- セキュリティ脆弱性 High/Critical なし
- パフォーマンステスト要件クリア
- 全テストケース成功

### 7.4 セキュリティベストプラクティス

#### 7.4.1 AI生成コードのセキュリティ検証

**セキュリティチェックポイント**:
- インジェクション攻撃対策
- 認証・認可の実装
- 機密データの取り扱い
- 暗号化の適切な実装
- ログ出力の安全性

**自動化セキュリティツール**:
- SAST (Static Application Security Testing)
- DAST (Dynamic Application Security Testing)
- SCA (Software Composition Analysis)
- Container Security Scanning

#### 7.4.2 AI使用時のデータプライバシー

**プライバシー保護策**:
- 個人情報をプロンプトに含めない
- テストデータの匿名化
- ログファイルの適切な管理
- AIサービスの利用規約確認

---

## 8. 課題解決とトラブルシューティング

### 8.1 よくある課題と解決策

#### 8.1.1 AI生成コードの品質課題

**課題**: AIが生成したコードが期待する品質に達しない

**原因分析**:
- プロンプトの曖昧さ
- コンテキスト情報の不足
- 技術要件の不明確さ
- AIモデルの限界

**解決策**:
```markdown
1. プロンプトの改善
   - より具体的な要件記述
   - 技術仕様の明確化
   - 期待品質の定義

2. 段階的アプローチ
   - 小さな単位での生成
   - 段階的な詳細化
   - 継続的な検証

3. 人間による監督強化
   - 専門家によるレビュー
   - ペアプログラミング
   - 品質チェックリスト活用
```

#### 8.1.2 チーム協働の課題

**課題**: モブ手法がうまく機能しない

**原因分析**:
- 役割分担の不明確さ
- ファシリテーションスキル不足
- 物理環境の制約
- チーム内の協力不足

**解決策**:
```markdown
1. 環境改善
   - 適切な作業環境の整備
   - 必要なツールの準備
   - 快適性の確保

2. スキル向上
   - ファシリテーション研修
   - チームビルディング
   - コミュニケーション技術向上

3. プロセス調整
   - 明確な役割定義
   - 時間管理の改善
   - 定期的な振り返り
```

#### 8.1.3 技術的統合課題

**課題**: 既存システムとの統合が困難

**原因分析**:
- レガシーシステムの制約
- API設計の不整合
- データ形式の差異
- セキュリティ要件の競合

**解決策**:
```markdown
1. 段階的移行
   - Strangler Fig パターンの採用
   - 漸進的な置き換え
   - 並行運用期間の設定

2. アダプターレイヤー
   - 変換層の実装
   - プロトコル変換
   - データマッピング

3. AIによる移行支援
   - 既存コード分析
   - 移行計画生成
   - テストケース作成
```

### 8.2 継続的改善メカニズム

#### 8.2.1 定期的レビュー体制

**週次レビュー**:
- チーム振り返り
- AI活用効果測定
- 課題の早期発見
- 改善アクション計画

**月次レビュー**:
- プロセス効果性評価
- KPI達成状況確認
- 組織間連携状況
- 教育・研修効果

**四半期レビュー**:
- 戦略的目標達成度
- 投資対効果分析
- 組織変革進捗
- 次期計画策定

#### 8.2.2 ナレッジマネジメント

**知識蓄積**:
- 成功事例データベース
- 失敗事例と教訓
- ベストプラクティス集
- プロンプトライブラリ

**知識共有**:
- 定期的な勉強会
- 事例発表会
- メンタリングプログラム
- 外部コミュニティ参加

---

## 9. 付録

### 9.1 プロンプトテンプレート集

#### 9.1.1 要件定義テンプレート

```markdown
# 要件定義プロンプト - Version 2.0

## ゴール
事業部との議論内容を整理し、実装可能な要件として構造化する

## AIの役割
- プロダクトオーナー支援
- ビジネス価値の明確化
- 技術的実現性の検討
- 曖昧さの解消

## コンテキスト
### プロジェクト概要
- システム名：[システム名]
- 対象業界：[業界]
- 主要ユーザー：[ユーザータイプ]
- ビジネス目標：[目標]

### 技術環境
- フロントエンド：[技術スタック]
- バックエンド：[技術スタック]
- データベース：[DB種類]
- インフラ：[クラウド/オンプレ]

### 制約条件
- 予算：[予算制約]
- 期間：[スケジュール制約]
- 規制：[コンプライアンス要件]
- 技術：[技術的制約]

## 期待アウトプット
### 1. 背景と目的
### 2. ビジネス課題と期待価値
### 3. 機能要件
### 4. 非機能要件
### 5. 制約条件・前提
### 6. 確認必要事項

## 入力情報
[会議記録、資料、補足情報を記載]
```

#### 9.1.2 コード生成テンプレート

```markdown
# コード生成プロンプト - Version 2.0

## 生成対象
- コンポーネント：[対象コンポーネント]
- 機能：[実装機能]
- 言語・フレームワーク：[技術スタック]

## 要件
### 機能要件
- [機能1]
- [機能2]
- [機能3]

### 非機能要件
- パフォーマンス：[要件]
- セキュリティ：[要件]
- 可用性：[要件]

### 技術制約
- アーキテクチャパターン：[パターン]
- 設計原則：[原則]
- 外部連携：[連携先]

## 品質基準
- コーディング規約：[規約]
- テストカバレッジ：[基準]
- ドキュメント：[要求レベル]

## 期待アウトプット
1. 実装コード
2. 単体テスト
3. 技術文書
4. 使用方法
```

### 9.2 チェックリスト集

#### 9.2.1 要件レビューチェックリスト

**ビジネス観点**:
- [ ] ビジネス価値が明確に定義されている
- [ ] 対象ユーザーが特定されている
- [ ] 成功指標が測定可能である
- [ ] 優先度が適切に設定されている
- [ ] 事業部の合意が得られている

**技術観点**:
- [ ] 技術的実現可能性が確認されている
- [ ] 非機能要件が適切に定義されている
- [ ] 外部システム連携が考慮されている
- [ ] セキュリティ要件が明確である
- [ ] 運用・保守性が考慮されている

**プロセス観点**:
- [ ] 受け入れ基準が明確である
- [ ] テスト戦略が定義されている
- [ ] リスクが識別・評価されている
- [ ] 依存関係が明確である
- [ ] 完了定義が設定されている

#### 9.2.2 コードレビューチェックリスト

**機能品質**:
- [ ] 要件通りの動作をする
- [ ] エラーハンドリングが適切
- [ ] 境界値処理が正しい
- [ ] パフォーマンスが要件を満たす
- [ ] セキュリティホールがない

**設計品質**:
- [ ] SOLID原則に準拠している
- [ ] 適切な設計パターンが使用されている
- [ ] 命名規則が一貫している
- [ ] 依存関係が適切に管理されている
- [ ] 拡張性が考慮されている

**保守性**:
- [ ] コードが読みやすい
- [ ] コメントが適切に記載されている
- [ ] 複雑度が適切な範囲内
- [ ] 重複コードがない
- [ ] テストが十分にある

### 9.3 メトリクス定義

#### 9.3.1 開発効率メトリクス

**速度指標**:
- リードタイム：要件から本番リリースまでの時間
- サイクルタイム：開発開始から完了までの時間
- デプロイ頻度：本番環境への継続的なリリース頻度
- 復旧時間：障害発生から復旧までの時間

**生産性指標**:
- 機能ポイント/時間：単位時間あたりの機能実装量
- ストーリーポイント/ボルト：イテレーションでの完了作業量
- コード生産性：LOC/時間またはFunction Points/時間
- 再作業率：手戻り作業の割合

#### 9.3.2 品質メトリクス

**コード品質**:
- テストカバレッジ：コードベースのテスト網羅率
- 複雑度：循環的複雑度の平均値
- 重複率：重複コードの割合
- 技術的負債：SonarQube等による負債指標

**システム品質**:
- バグ密度：リリース後に発見される不具合数
- 可用性：システム稼働率
- レスポンス時間：応答性能指標
- スループット：処理能力指標

### 9.4 用語集

**AI-DLC関連用語**:
- **AI-DLC**: AI-Driven Development Lifecycle - AI駆動開発ライフサイクル
- **Intent**: 高レベルなビジネス意図や目的
- **Unit**: 独立して開発可能な機能ブロック
- **Bolt**: 短期間の集中的な開発イテレーション（従来のスプリントに相当）
- **モブ要件詳細化**: AIと協働してチーム全体で要件を詳細化する手法
- **モブ構築**: AIと協働してチーム全体でソフトウェアを構築する手法

**技術用語**:
- **ドメインモデリング**: 業務領域の概念と関係性をモデル化する手法
- **TDD**: Test Driven Development - テスト駆動開発
- **BDD**: Behavior Driven Development - 振る舞い駆動開発
- **CI/CD**: Continuous Integration/Continuous Deployment
- **IaC**: Infrastructure as Code

**プロセス用語**:
- **RACI**: Responsible, Accountable, Consulted, Informed
- **INVEST**: Independent, Negotiable, Valuable, Estimable, Small, Testable
- **Definition of Done**: 完了の定義
- **Acceptance Criteria**: 受け入れ基準

### 9.5 参考資料

#### 9.5.1 推奨書籍
- 「ドメイン駆動設計」Eric Evans著
- 「クリーンアーキテクチャ」Robert C. Martin著
- 「LeanとDevOpsの科学」Nicole Forsgren他著
- 「チームトポロジー」Matthew Skelton他著

#### 9.5.2 オンラインリソース
- AWS AI/ML Blog
- Anthropic Documentation
- GitHub Copilot Documentation
- Martin Fowlerのブログ

#### 9.5.3 トレーニングプログラム
- AI-DLC Unicorn Gym（AWS提供）
- ドメイン駆動設計ワークショップ
- モブプログラミング研修
- プロンプトエンジニアリング基礎

---

## まとめ

本ガイドラインは、AI駆動開発の実践を通じて、組織の開発力を飛躍的に向上させることを目的としています。成功の鍵は、段階的な導入、継続的な学習、そしてチーム全体での協働にあります。

AI-DLCは単なる技術的な変革ではなく、組織文化の変革でもあります。人間とAIが協働する新しい働き方を通じて、より創造的で価値ある開発体験を実現していきましょう。

変革は一朝一夕には実現できませんが、小さな一歩から始めることで、必ず大きな成果を得ることができます。このガイドラインを活用し、AI駆動開発の旅を始めてください。